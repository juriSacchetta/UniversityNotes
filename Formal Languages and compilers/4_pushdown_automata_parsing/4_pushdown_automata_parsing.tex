\chapter{Pushdown automata and parsing}
	Pushdown automaton: a finite state machine enriched with a LIFO queue (or \emph{stack}) as memorization device, that supports the classical push-pop operations. 
	It's useful to portay this device with a terminator on the bottom, so that it signals the emptiness of the stack. Even a single-state nondeterministic pushdown 
	automaton can (with only the stack) be used as a recognizer; this is called \emph{daisy automaton}.

	To define a pushdown automaton we just expands the FSA deefinition with the stack alphabet and a special character from this alphabet, the stack bottom / terminator 
	/ initial stack symbol. REMEMBER: the transiction function doeas not depends solely on the given input anymore, but also on the stack's top symbol; the domain is 
	changed, wrt the classic FSA.

	Domain and range of the transiction function for a FSA: (set of states) $\times$ (input alphabet) $\rightarrow$ (set of states)

	Domain and range of the transiction function for a PDA: (set of states) $\times$ (input alphabet) $\times$ (stack alphabet) $\rightarrow$ (set of states) 
	$\times$ (stack alphabet)

	In the graph for a pushdown automaton, also the stack operation must be specified.
	\textbf{\underline{A pushdown automaton is as expressive as a context free grammar}}
	
	\section{Deterministic stuff}
		Only deterministic context free languages (so, accepted by deterministic PDA) are considered in the field of compilers, due to efficiency and complexity 
		reasons.

		Non determinism can be found in PDA in 2 forms mainly:
		\begin{itemize}
			\item the transiction function is multi valued (it has more than one possible output for certain input)
			\item spontaneous moves \emph{interfere} with the recognizing procedure, in particular
				\begin{itemize}
					\item a spontaneous move and a reading move are defined and they overlap
					\item a spontaneous move is multi-valued
				\end{itemize}
		\end{itemize}
		
		\subsection{Deterministic languages family}
			The DET family (the context free languages that can be recognized by a deterministic PDA) is a proper subset of the CF languages family.

			This family is closed under these operators:
			\begin{figure}[htp]
				\begin{center}
					\includegraphics[width = \textwidth]{./images/detClosures.png}
					\caption{Closures properties of deterministic languages}
				\end{center}
			\end{figure}
	
	\section{Parsing}
		Parsing (syntax analysis) is the procedure to estabilish if a string belongs to a certain language. A parser is an automaton that puts in place the analysis. 
		It compute the syntax trees or gives an error if it finds one.
		
		\subsubsection{Types of parsing}
			Parsers can be classified in top-down parsers and bottom-up parsers (another distinction that's totally new to CS students, uh?) to distinguish between 
			the approach to the syntax trees.
			\begin{itemize}
				\item \emph{top down} analyzers grow the tree from the root downwards towards the leaves; this means that every step of the algorithm corresponds to 
				a \emph{derivation in the grammar} so a \emph{left} $\rightarrow$ \emph{right} passage in a rule
				\item \emph{bottom up} parsers starts from the leaves of the syntax tree and reach the root; this means that every step of the parsing procedure 
				corresposnds to a \emph{reduction in the grammar}, so a \emph{right} $\rightarrow$ \emph{left} passage in a rule
			\end{itemize}
		
		\subsection{Grammars as networks of finite automata}
			To build a recognizer for a grammar, we can see it as a set of indipendent productions for each nonterminal. Every nonterminal is associated with a 
			dedicated machine (a FSA, for example) that when has to read another nonterminal just "invokes" another machine to do so.

			This means that, at the end of the transformation, we have a machine for every nonterminal, that can interpret all the productions of said nonterminal, 
			and on the arcs has all and only the right-side elements of the rule taken into account.
			
			\subsubsection{Good example}
				We consider a grammar that generates arithmetic expressions.
				\begin{figure}[htp]
					\begin{center}
						\includegraphics[]{./images/exGrammar.png}
					\end{center}
				\end{figure}
				We isolate the three nonterminals E, T and F and build a machine for each one of them
				\begin{figure}[htp]
					\begin{center}
						\includegraphics[]{./images/exE.png}
					\end{center}
				\end{figure}
				\begin{figure}[htp]
					\begin{center}
						\includegraphics[]{./images/exT.png}
					\end{center}
				\end{figure}
				\begin{figure}[htp]
					\begin{center}
						\includegraphics[]{./images/exF.png}
					\end{center}
				\end{figure}
				
		\subsection{Lookahead sets}
			All parsers are implemented as DPDA. They rely on a second component, the lexical analyzer, that reads the input stream and recognizes the patterns in it 
			in order to separate all the lexeme (or tokens) to give to the parser itself.

			To ensure the automaton is actually deterministic, parsers \emph{preprocess} the grammar's rules, and select the sets of tokens that can be read after 
			each move; these are the \emph{followers} or \emph{lookahead} set. These sets of token are useful when another machine in the network must be called: 
			it's necessary to know which character we \emph{will} read and compare it with the first character read in the machines. To be noted: each 
			\emph{nonterminal, for each configuration,} has a set of lookahead characters. 
			
			\subsubsection{Lookahead and closures}
				Each pair \{state, token\} is said to be a candidate if the token is a legal lookahed character for the current activation of the machine in state 
				"state". That does not mean so much, at the end of the day.

				To compute each set of candidates we use a \emph{closure function}. The closure function is defined this way:

				Let \emph{C} be a set of candidates:
				\begin{equation}
					\text{closure(\emph{C})} =
					\begin{cases}
				  		\text{\emph{C}} \\
				  		\langle 0_b, b \rangle \in \text{closure(\emph{C}) if }
				  		\begin{cases}
				  			\exists \text{ candidate } \langle q, a\rangle \in \text{\emph{C} \textbf{and}}\\
				  			\exists \text{ arc in the machine net so that } q \xrightarrow{B} r \text{\textbf{ and}}\\
				  			b \in \text{Ini(L(r)} \cdot a \text{)}
				  		\end{cases} 
					\end{cases}
			  	\end{equation}
			  	EXPLANATION OF THE FORMULA: the formula returns a \emph{set of candidates}, so a set of pairs $\langle$ state, character $\rangle$. Its input is 
				\emph{another set of candidates}, so the output will be the closure not of a unique state, but of a set of them. The formula states that a candidate 
				can be in the closure if:
			  	\begin{itemize}
			  		\item The candidate \emph{is} the closure;
			  		\item The candidate is composed of an initial state (in the formula written as $0_b$) of a machine in the network and a character ("b") which is 
					in the set of initials of a language that is \emph{reached through machine B}.
			  	\end{itemize}
			  	Notice how subtle the recursivity is: in order to compute a language of a state (L(r) in this case) we should build the closure of the candidates 
				starting from state r. The fixed point is reached when state r is final, so L(r) is $\epsilon$ thus the following character ("a" in the formula) is 
				added to the candidate.
			
			\subsubsection{Meaningful example}
				We consider grammar G
				\begin{equation}
					G = 
					\begin{cases}
						E \rightarrow T^\ast\\
						T \rightarrow \text{'(' } E \text{ ')' } \vert \text{ a}
					\end{cases}
				\end{equation}
				that generates expressions and terms. We consider the machine network
				\begin{figure}[H]
					\begin{center}
						\includegraphics[width = \textwidth]{./images/exNetwork.png}
					\end{center}
				\end{figure}
				We compute the closure for candidate $\langle 0_e, \dashv \rangle$
				\begin{itemize}
					\item $\langle 0_e, \dashv \rangle$
					\item $\langle 0_t, \text{ ( }\rangle$
					\item $\langle 0_t, \text{ a }\rangle$
					\item $\langle 0_t, \dashv \rangle$
				\end{itemize}
		
		\subsection{ELR parsers}
			ELR = Extended Left to right Rightmost

			When reducing a string in input, a bottom up parser has two possible moves available: \emph{shift} to the next character (that simply means that a new 
			state is pushed on the stack and no pattern has been recognized yet) or \emph{reduce}: this means that a pattern (a right part of a rule) has been fully 
			recognized and a state can be popped from the stack. These two operations are an adapted version of the pop-push model for the memory. They also represent 
			the moving forward and backward in the rules of the grammar.

			ELR is the name for the parsers that recognize a EBNF grammar.

			To build the recognizer starting from the grammar a three-phase method has been outlined:
			\begin{enumerate}
				\item (Prerequisites: we have a network of machines that describes the grammar's rules) We build a special automaton called \emph{pilot automaton} 
				that is a generalization of the machines network. It covers all the possible combination of states and input.
				\item The pilot is inspected to check if it's suitable for deterministic parsing, and three types of failure are searched for (we'll discuss them 
				in a moment).
				\item If the test at point 2 is passed, then the DPDA is built from the pilot. 
			\end{enumerate}
			
			\subsubsection{Construction of the pilot automaton}
				The pilot automaton is (as already said) a method to represent \emph{all} the possible computational path of another one. Every state (called macro 
				state or m-state) is labeled as all the states it represents, and all the arcs keep in consideration all the possible reading for all the possible 
				states encapsulated in a single m-state.

				Every state is divided in 4 parts:
				\begin{itemize}
					\item the two (canonically) upper parts are the \emph{base} candidates: the states and lookahead characters of \textbf{non initial} state;
					\item the two (canonically) lower parts are reserved to the \emph{kernel} candidates: the states and associated lookahead of the 
					\textbf{initial} state.
				\end{itemize}
				Every final state in every m-state is usually highlighted (to help spot reductions).

				An algorithm that creates a pilot automaton can be described in this way:
				\begin{enumerate}
					\item The initial state groups the first state of the first accessed machine AND all the states of the machine that can be reached with a 
					$\epsilon$-move. (So? They're all the first states of the nonterminals that \emph{label} the outgoing arcs from the initial state. Being 
					all initial states \emph{for construction}, first m-state does not have the base part)
					\item All the other states are built in a similar way: following an arc, I add all the state that I can found to the next m-state; I select 
					the initial ones and put them in the closure, then I check for states that are reachable through a $\epsilon$-move, and also add them to the 
					closure. For the closure part, I shall recalculate the lookaheads, things that \emph{generally} I do not do with the pure base part.
				\end{enumerate}
				Is a pilot automaton still a PDA? Yes: the extra labeling of the states and the interpretation of the strings can be seen as pushing and poppoing 
				the entire candidates onto the stack and popped back when needed.
				
			\subsubsection{Meaningful example}
				We build the pilot automaton for the grammar in (5); at first glance, it can seem overly complicated, so I'll add a list of things to be noted.
				\begin{itemize}
					\item All m-states have a number of outgoing arcs that's equal to the number of outgoing arcs of \emph{all his states combined}
					\item The first state has no base part
					\item \underline{Following a path on the machine chart translates in "inheriting" the lookahead set}
					\item Watching the graph, there are two visible subsets that represents the two possible paths towards the accepting states: one in the 
					"upper level" (which has as a lookahead $\dashv$) and one in the "nested level". The first is composed of the states 
					\{$I_0$, $I_3$, $I_8$, $I_2$\} and the second one of the states \{$I_3$, $I_6$, $I_7$, $I_5$\}
				\end{itemize}
				\begin{figure}[H]
					\begin{center}
						\includegraphics[]{./images/pilotAutomaton.png}
					\end{center}
				\end{figure}
				
			\subsubsection{Another meaningful example}
				Without forgetting we are at the \emph{first} step of our DPDA building, I add another good example.

				We start from this machine sets:
				\begin{figure}[H]
					\begin{center}
						\includegraphics[width = \textwidth]{./images/ex2.png}
					\end{center}
				\end{figure}
				We derive the pilot automaton with the algorithm described above:
				\begin{figure}[H]
					\begin{center}
						\includegraphics[width = \textwidth]{./images/ex2Pilot.png}
					\end{center}
				\end{figure}
				Again, I add a short list of things to be noted
				\begin{itemize}
					\item the first transition labeled "a" is the perfect example of \emph{following a paht makes you inherit lookaheads};
					\item m-states $I_3$ and $I_6$ represents the same states, but with different lookaheads;
				\end{itemize}
				
			\subsubsection{Deterministic check (also called ELR condition)}	
				The three possible failures in deterministic check:
				\begin{itemize}
					\item shift reduce conflicts: both a shift and a reduce are a possible in a certain configuration. This means that in a pilot automaton for all 
					the candidates $\langle q, \pi \rangle \in I$ so that q is final and for all the arcs $I \xrightarrow{a} I'$ that go out from I with terminal 
					label a it must hold that $a \notin \pi$;
					\item reduce reduce conflicts: two possible (or more) reduce paths are possible in a given configuration. In a pilot automaton, it's formulated 
					as: for all the candidate $\langle q, \pi \rangle, \langle r, \rho \rangle \in I$ that q and r are both final it must hold that 
					$\pi \cap \rho = \emptyset$;
					\item convergence conflicts: two different computations share a lookahead and a future state (this could cause reducing conflicts). This conflict 
					is the most tricky to discover, as it can only be done analyzing the graph manually: the condition to be met is something like "no different 
					states in a single m-state share a lookahead and a state".
				\end{itemize}
				
			\subsubsection{Parser algorithm}
				We focus on the implementation that makes use of a vector stack, so a LIFO memory with has also and index-like access (like vectors. You should guess 
				what a vector stack is). This enables the parser to save the exact position to return to when a reduce move is performed, accessing directly the cell 
				pointed with the saved index.

				The accepting procedure is quite obvious: the pilot automaton is traversed following the arcs when a new term is read, and reducing when the next term 
				is equal to the lookahead char in the m-state. Accepting is when we reach a final state and we only have the axiom on the stack. This procedure is an 
				incremental process: every time a m-state is leaved, on the stack are pushed all the possible candidates, and the next m-state will save the pointer 
				(index) to the previous one and so on, so that at reduce time the parser can pop off all the states from the stacks just following the indexes.

				(The official and formal way to describe the algorithm is leaved to the curious reader: page 271+ of the "Formal languages and Compilation" book from 
				Reghizzi, Breveglieri, Morzenti)
		
		\subsection{ELR parser re written}
		This question is exercise $3$ in the exam.
			ELL and ELR are two different methods to build parsers.
			Let's analyse ELR starting from an example:
			\begin{figure}[H]
				\centering
                \subfloat[][\emph{Machine A}]{
					\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
						\node[] (initial) {$A$};
						\node[state] (0a) [right of =initial]      {$0_A$};
						\node[state]         (1a) [right of=0a]  {$1_A$};
						\node[] (final)[right of =1a]{};
						
						\path[->](initial) edge node {} (0a);
						\path[->]          (0a)  edge node {c} (1a);
						\path[->]          (1a)  edge node {} (final);
					\end{tikzpicture}
					\label{fig:A}
				} \\
                \subfloat[][\emph{Axiom $S$}]{
					\resizebox{0.9\textwidth}{!}{
						\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
							\node[] (initial) {$S$};
							\node[state] (0s) [right of =initial]      {$0_S$};
							\node[state]         (1s) [right of=0s]  {$1_S$};
							\node[state]         (2s) [right of=1s]  {$2_S$};
							\node[state]         (3s) [right of=2s]  {$3_S$};
							\node[state]         (4s) [right of=3s]  {$4_S$};
							\node[] (final)[right of =4s]{};
							
							\path[->](initial) edge node {} (0a);
							\path[->]          (0s)  edge node {a} (1s);
							\path[->]          (1s)  edge node {a} (2s);
							\path[->]          (2s)  edge node {b} (3s);
							\path[->]          (3s)  edge node {c} (4s);
							\path[->]          (4s)  edge node {} (final);
							\path[->][in=45,out=135]          (3s)  edge node [swap ]{$A$} (1s);
							\path[->][in=-45,out=-135]          (4s)  edge node {$C$} (2s);
						\end{tikzpicture}
					}
					\label{fig:B}
				}\\
				\subfloat[][\emph{Machine C}]{
					\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
						\node[] (initial) {$C$};
						\node[state] (0c) [right of =initial]      {$0_C$};
						\node[state]         (1c) [right of=0c]  {$1_C$};
						\node[state]         (2c) [right of=1c]  {$2_C$};
						\node[] (final)[right of =2c]{};
						
						\path[->](initial) edge node {} (0a);
						\path[->]          (0c)  edge node {d} (1c);
						\path[->]          (2c)  edge node {} (final);
						\path[->][in=135,out=45]          (1c)  edge node {$S$} (2c);
						\path[->][in=-135,out=-45]          (1c)  edge node {$a$} (2c);
					\end{tikzpicture}
					\label{fig:C}
				}
                \caption{Example}
                \label{fig:mainexample}
			\end{figure}
			ELR: tries to completely match one machine to the prefix it finds. If it recognizes it, one of these three nonterminal symbols is attributed to it.
			\begin{definition}[Reduction]
				The production substitutes the expansion of the production with the symbol of the rule
			\end{definition}
			We want to perform reductions until we are left with only one symbol: the one of the axiom (considering figure \ref{fig:mainexample}, $S$): at that point 
			we have recognized a string.

			We will see the algorithm in a momnent, after some critical points we need to clarify: at the first stwp we want to create the initial state of the pilot 
			automaton. How? we want to compute the closure of the initial state of the axiom.
			\begin{definition}[Closure]
				Is the set of all the candidates that can be found from a given state and the lookahead.
			\end{definition}
			Let's dig more into this definition, looking at what is a \textbf{candidate} and the \textbf{lookahead} in an informal way.

			ELR wants to find the longest prefix: the candidate basically tells to the algorithm ``\emph{I think that at this point we will possibly recognize in
			the end one of these three machines}''. After recognizing one of the production (say $A$ or $C$ in the example), there must be an additional character.
			This is the secret sauce of ELR algorithm, and is what ives us the certainty (if we are in ELR1 case, we will see what this mean) that we are not 
			doing a false match. For example: $c$ can appear inside $s$, or can be the entire tree production of $A$. How do we distinguish this case?
			\begin{itemize}
				\item To recognize $A$ (i.e., if $c$ comes from $A$, figure \ref{fig:A}), we must find for example $a$ coming from 
				$1_S\overset{a}{\longrightarrow}2_S$ after character in $A$, because we can 
				only recognize $A$ taking the arc $3_S\overset{A}{\longrightarrow}1_S$. In this case, $a$ coming from $1_S\overset{a}{\longrightarrow}2_S$ is the 
				\textbf{lookahead} (the character that comes \emph{after} having recognized $A$), which gives the certainty that we recognized $A$.
				\item If the $c$ instead came from $3_S\overset{c}{\longrightarrow}4_S$ (figure \ref{fig:B}), after that we have the production $C$, and its first 
				character is $d$ ($0_C\overset{d}{\longrightarrow}1_C$), which is different from $a$.
			\end{itemize}
			So, when we arrive in $3_S$ (fig \ref{fig:B}), we have two candidates:
			\begin{enumerate}
				\item $3_S\longrightarrow 4S$ in which we continue recognizing the production $S$.
				\item $3_S\longrightarrow 0A$ in which we start recognizing the production $A$.
			\end{enumerate}
			ELR looks at all these possible candidates in parallel. Until we read the $c$ and the lookahead, we don't know which is the option in which we are: 
			we need to bring on all the possible options until we find the correct lookahead (at that point we have found the correct candidate tha we need to 
			continue parsing the string).

			Candidates are tuples:
			\begin{equation*}
				C=\langle q,r\rangle
			\end{equation*}
			where:
			\begin{itemize}
				\item $q$: A machine of the state;
				\item $r$: $\Sigma$, where $\Sigma$ is the alphabet, (while $V$ are the nonterminals, hot present here).
			\end{itemize}
			In every state of ELR, we have these states (separate from states of the machine of the production), which are called \emph{macro states}, or 
			\emph{m-states}.
			
			In each state of the pilot we have a set of candidates: the transitions of ELR recognizes all the set of characters in the alphabet and the 
			nonterminals, becausr when we replace production with nonterminal symbols, is what the pilot need to be able to do: replace the production with the 
			correct nonterminal symbol.

			Let's see how we build transitions and symbols:
			Initial state is built from all the initial candidates that can be found at the beginning of the string. Since we are at the beginning of the 
			string, at the end, the look ahead will be defined by at least $\dashv$ ($4_S\longrightarrow$), because when we will recognize $S$, at the end of $S$,
			when we have finished recognizing the whole string, we have the terminal character. In some cases additionally we will have some transition that 
			from the initial state of the axiom enters another machine: in that case we will have multiple lookaheads. The initial state will contain the closure 
			of $0_S$ and $\dashv$ ($\langle 0_S,\dashv\rangle$). In order to build the closure of a state we have to control all transition outgoing from $0_S$ in 
			this case. The candidates we have next, will depend from the state we are in.

			In this case, at the beginning we are in $0_S$, and the terminal character (we do not have extra candidates that need to be added).
			At the beginning we have just $0_S,\dashv$ at the beginning, and we add this new state inside the 
			ELR pilot machine. Le'ts see the two section of a node in ELR:
			\begin{itemize}
				\item \emph{base set}: elements from the closure that still belong to the original machine (in this case $S$);
				\item \emph{closure set}: contains elements of the closurethat belongs to a new machine
			\end{itemize}
			We are starting, we do not have another state, we started from nothing, hence everything goes in closure set:
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,] {
						\begin{tabular}{|cc|} \toprule
							\hline
							$0_s$ & $\dashv$\\
							\hline
						\end{tabular}
						};
				\end{tikzpicture}
			\end{figure}
			In the slides, when we see \emph{closure(C)}, we don't mean only the closure set, but the entire closure!
			Now let's go on to produce the next state. Now, we need to look at all characters in the alphabet and all the nonterminals, 
			and we need to check if there is a transition from one of the states that appears in the various candidates, so for example, 
			in this case just $0_S$. For each character in the set $abcsASC$, if there is a transition that recognizes one of 
			those character from one or multiple of the states in the candidates, then we add a new transition to a new state inside the pilot.
			From $0_S,\dashv$, we have one single transition towards $1_S$ with $a$. We draw an arrow in the pilot, and the next state 
			is produced from the closure of the next state that we are going to from the next state in the $S$ machine. We were starting from $0_S,\dashv$:
			now we need to compute the closure of $\langle 1_S,\dashv\rangle$. How did we arrive to $\langle 1_S,\dashv\rangle$? we follow the transition 
			that in machine $S$ brought us to $1_S$ through $a$, and we change the state in the candidate from the initial to the final state.

			The closure of something is defined as our initial candidate itself ($1_s,\dashv$), and look at all possible transitions that from $1_S$ 
			bring us to another state, but only through one of the nonterminal symbols. The only transition does not take a nonterminal symbol. There is nothing 
			else to add in the closure, and we have finished. The building of the state is complete.
			We need now to finalize the state: what there will be in the base set? all the closure copied from the closure. we have computed the closure of 
			$1_S,\dashv$: since the closure is equal to $1_S,\dashv$ (is the closure of itself), is the base set. Then we add the closure set (new parts of new machines),
			which is empty (just put an horizontal line.)
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_s$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_s$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};

					\path[->](initial) edge node {a} (first);
				\end{tikzpicture}
			\end{figure}
			And we go on. we have finished with the first state ($0_S$), we have looked at all transition from initial states to all candidates, and we 
			will mark the state as completed (we'll never touch it again):
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_s$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_s$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};

					\path[->](initial) edge node {a} (first);
				\end{tikzpicture}
			\end{figure}
			And consider the candidate $1_S,\dashv$. From $1_S$, we have only one transition which reads $a$: we don't have to compute the closure of $1_S,\dashv$, 
			but of $2_S,\dashv$. Do we have additional production we can reach from $2_S$. We don't have a transition that recognizes a new symbol, hence we don't have
			anything to add to the closure set.:
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};

					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
				\end{tikzpicture}
			\end{figure}
			Let's go on from $2_S$. Same situation. We can reach $3_S$ by reading $b$, and there is no other transition:
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (third) [shape=rectangle] [right of = second]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};

					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
					\path[->](second) edge node {b} (third);
				\end{tikzpicture}
			\end{figure}
			In slides, $\delta$ , it takes one candidate, and it computes the candidates that follows a certain symbol:
			\begin{equation*}
				\delta(\langle 0_S,\dashv\rangle)=\langle 1_S,\dashv\rangle
			\end{equation*}
			We just replace the state.
			Now, in $3_S$ we have a transition that goes to a new nonterminal symbol: $3_S\overset{A}{\longrightarrow}1_S$.
			We are computing the closure of $3_S$, and we go to another state in the machine by recognizing the nonterminal symbol, 
			we need to add a new candidate in the closure set: it's not the state $1_S$, is the initial state of the machine we are 
			recognizing the nonterminal of, $A$, hence we add $0_A$, and the lookahead will be the character (or the set of characters) 
			that come after $A$ in the original machine. Here, after recognizing $A$, in $S$ we find $a$: this is our lookahead:
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (third) [shape=rectangle] [right of = second]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $\dashv$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};

					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
					\path[->](second) edge node {b} (third);
				\end{tikzpicture}
			\end{figure}
			This is the important part. If we have a nonterminal between $1_S$ and $2_S$, we can't write $a$ in the closure, 
			we need to go into the machine of that nonterminal, and check the character in that machine. If there is still a 
			nonterminal character, go ahead until you find a nonterminal character.

			Let's finish computing the set of candidates: when we add a new candidate as in this case ($0_A$), we have to 
			recursively check if this adds new candidates. This does not happens: it has not transitions to nonterminal symbols, 
			but it might happen. we have finished building the closure, we need to produce the new states and transitions. Look at 
			all states, and look what is recognized. Both $0_A$ and $3_S$ recognize $c$. Add a single arc that corresponds to $c$.
			At this point, advance all the candidates where we have a recognition from the initial state of $c$, not all candidates in general.
			Only look at the ones that whose state is a state that can recognize $c$ with an outgoing transition. Advance both $3_S$ and $4_S$.
			From $3_S$ we go to $4_S$ (keep the same lookahead), and with $0_A$ we go to $1_A$, bringing forward lookahead ($a$), and this is the 
			base set:
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (third) [shape=rectangle] [right of = second]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $\dashv$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (fourht) [shape=rectangle] [below of = third]{
						\begin{tabular}{|cc|}
							\hline
							$4_S$ & $\dashv$\\
							$1_A$ & $a$\\
							\hline
							\hline
						\end{tabular}
					};

					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
					\path[->](second) edge node {b} (third);
					\path[->](third) edge node {c} (fourht);
				\end{tikzpicture}
			\end{figure}
			Let's now check if one of these two new states have a transition that recognizes a nonterminal. $1_A$ is a final state 
			(no other transitions from there), from $4_S$ we have a transition that recognizes $C$:
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (third) [shape=rectangle] [right of = second]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $\dashv$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (fourht) [shape=rectangle] [below of = third]{
						\begin{tabular}{|cc|}
							\hline
							$4_S$ & $\dashv$\\
							$1_A$ & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};

					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
					\path[->](second) edge node {b} (third);
					\path[->](third) edge node {c} (fourht);
				\end{tikzpicture}
			\end{figure}
			The closure as we notice is just $b$, $2_S$ has no other transitions or recursion. But, we have also a transition from $3_S$, in 
			which we can recognize $A$ (other than one with $c$): These transitions with nonterminals, are not different, count as the transitions with 
			terminals: we need to add these transitions also in the pilot graph. Let's build the new state in this case: we need to bring 
			ahead candidates that recognizes $A$, in this case just $3_S,\dashv$. We go to $1_S$, the state of the new candidate (with the same lookahead). Look 
			at the closure of this state: from $1_S$, we have no transitions that goes to another state through a nonterminal: this state is finished here:
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (third) [shape=rectangle] [right of = second]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $\dashv$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (fourht) [shape=rectangle] [below of = third]{
						\begin{tabular}{|cc|}
							\hline
							$4_S$ & $\dashv$\\
							$1_A$ & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (fifth) [shape=rectangle] [below of = second]{
						\begin{tabular}{|cc|}
							\hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};

					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
					\path[->](second) edge node {b} (third);
					\path[->](third) edge node {c} (fourht);
					\path[->](third) edge node [swap] {A} (fifth);
				\end{tikzpicture}
			\end{figure}
			When we build a new state identical, with all set of candidates, as another state (the highlighted ones):
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,] [right of = initial, fill=yellow] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (third) [shape=rectangle] [right of = second]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $\dashv$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (fourht) [shape=rectangle] [below of = third]{
						\begin{tabular}{|cc|}
							\hline
							$4_S$ & $\dashv$\\
							$1_A$ & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (fifth) [shape=rectangle] [below of = second,fill=yellow]{
						\begin{tabular}{|cc|}
							\hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};

					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
					\path[->](second) edge node {b} (third);
					\path[->](third) edge node {c} (fourht);
					\path[->](third) edge node [swap] {A} (fifth);
				\end{tikzpicture}
			\end{figure}
			This means, that they are the \textbf{same} state, they are not different: we can never have two identical states (same set 
			of candidates). Hence, we did not need the last node:
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (third) [shape=rectangle] [right of = second]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $\dashv$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (fourht) [shape=rectangle] [below of = third]{
						\begin{tabular}{|cc|}
							\hline
							$4_S$ & $\dashv$\\
							$1_A$ & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};

					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
					\path[->](second) edge node {b} (third);
					\path[->](third) edge node {c} (fourht);
					\path[->](third) edge [in=-45, out=-135] node [swap] {A} (first);
				\end{tikzpicture}
			\end{figure}
			Be careful, always try to build closure: maybe state is not the same. Pay attention in sayng ``yes, it is duplicate''.
			Mark now the completion of the states:
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,fill=green] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle,fill=green] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (third) [shape=rectangle,fill=green] [right of = second]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $\dashv$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (fourht) [shape=rectangle] [below of = third]{
						\begin{tabular}{|cc|}
							\hline
							$4_S$ & $\dashv$\\
							$1_A$ & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};

					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
					\path[->](second) edge node {b} (third);
					\path[->](third) edge node {c} (fourht);
					\path[->](third) edge [in=-45, out=-135] node [swap] {A} (first);
				\end{tikzpicture}
			\end{figure}
			We need to go on with the fourth state, which has four candidates. Let's look at what becomes.
			\begin{itemize}
				\item From $4_S$ we can recognize $C$, or it is a final state.
				\item From $1_A$ we have finished parsing.
				\item From $0_C$ we can recognize $d$.
			\end{itemize}
			We have found two final states, $4_S$ and $1_A$. circle the final states for exam (just an additional thing, not necessary for ELR).
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,fill=green] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle,fill=green] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (third) [shape=rectangle,fill=green] [right of = second]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $\dashv$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (fourht) [shape=rectangle] [below of = third]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$4_S$} & $\dashv$\\
							\circled{$1_A$} & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};

					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
					\path[->](second) edge node {b} (third);
					\path[->](third) edge node {c} (fourht);
					\path[->](third) edge [in=-45, out=-135] node [swap] {A} (first);
				\end{tikzpicture}
			\end{figure}
			We need to go on with the fourth state, which has four candidates. Let's look at what becomes.
			\begin{itemize}
				\item From $4_S$ we can recognize $C$, or it is a final state.
				\item From $1_A$ we have finished parsing.
				\item From $0_C$ we can recognize $d$.
			\end{itemize}
			Anyway, we can start seing a pattern:
			\begin{enumerate}
				\item Consider all candidates (base or closure set)
				\item Follow each transition on the machines
				\item See in which state you go (copying lookahead when you stay in the same machine)
				\item Compute the closure if one of those in the base set has a Nonterminal after, and put in the closure set.
			\end{enumerate}
			Let's go on. Because from $4_S$ we can also read $C$: we need to add another arc which recognizes $C$. We are going from $2_S$, in which 
			we have already seen that we can only go to $3_S$ by reading $b$ (closure set empty), we don't have other transition that goes to a 
			non terminal state. We already have a state with the candidate $2_S,\dashv$:
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,fill=green] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle,fill=green] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (third) [shape=rectangle,fill=green] [right of = second]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $\dashv$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (fourht) [shape=rectangle] [below of = third]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$4_S$} & $\dashv$\\
							\circled{$1_A$} & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};

					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
					\path[->](second) edge node {b} (third);
					\path[->](third) edge node {c} (fourht);
					\path[->](third) edge [in=-45, out=-135] node [swap] {A} (first);
					\path[->](fourht) [in=-90, out=-135] edge node{C}(second);
				\end{tikzpicture}
			\end{figure}
			Let's look at the other candidates: $1_A$ and $0_C$: $1_A$ is a final state, but does not recognize anything else, so we do not need to do anything 
			more in order to take into account that candidate, because when we reach at that state, the next character is the one in the lookahead, and we can tell 
			if we have recognized the production $A$. From the pilot graph point of view, there is nothing else.
			From $0_C$, we can read $d$, and no other nonterminal symbols from there: we need to add a new transition to a new state which recognizes character $d$,
			and as base set that state will have the advancement of the candidate, with the same lookahead:
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,fill=green] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle,fill=green] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (third) [shape=rectangle,fill=green] [right of = second]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $\dashv$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (fourht) [shape=rectangle] [below of = third]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$4_S$} & $\dashv$\\
							\circled{$1_A$} & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (fifth) [shape=rectangle] [below of = first]{
						\begin{tabular}{|cc|}
							\hline
							$1_C$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};

					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
					\path[->](second) edge node {b} (third);
					\path[->](third) edge node {c} (fourht);
					\path[->](third) edge [in=-45, out=-135] node [swap] {A} (first);
					\path[->](fourht) [in=-90, out=-135] edge node{C}(second);
					\path[->](fourht) edge node [swap]{d} (fifth);
				\end{tikzpicture}
			\end{figure}
			And compute the closure: we can re-enter into $S$. We need to add a new candidate in the closure set:
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,fill=green] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle,fill=green] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (third) [shape=rectangle,fill=green] [right of = second]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $\dashv$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (fourht) [shape=rectangle] [below of = third]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$4_S$} & $\dashv$\\
							\circled{$1_A$} & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (fifth) [shape=rectangle] [below of = first]{
						\begin{tabular}{|cc|}
							\hline
							$1_C$ & $b$\\
							\hline
							\hline
							$0_S$ & $b$\\
							\hline
						\end{tabular}
					};
					
					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
					\path[->](second) edge node {b} (third);
					\path[->](third) edge node {c} (fourht);
					\path[->](third) edge [in=-45, out=-135] node [swap] {A} (first);
					\path[->](fourht) [in=-90, out=-135] edge node{C}(second);
					\path[->](fourht) edge node [swap]{d} (fifth);
				\end{tikzpicture}
			\end{figure}
			Why the lookahead is $b$? Is the next character we can read after the transition that recognizes our nonterminal symbol. But at 
			this point, after $2_C$, the machine $C$ ends: the character we read, is the same lookahead by recognizing $C$: we will have the lookahead that 
			we had before with $C$. This because when $S$ ends in $2_C$, also $C$ ends, so the lookahead is the same.
			
			N.B.: we did not added the $\dashv$! because 
			is just the production of $C$ that ended, the terminal character is only at the end of the final string, not at the end of every machine (production), because 
			this would result in $\dashv$ inside of the string.

			And you have to go on like this (from now on, only passages will be reported, since we have seen all the important cases that can happen).
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,fill=green] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle,fill=green] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (third) [shape=rectangle,fill=green] [right of = second]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $\dashv$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (fourht) [shape=rectangle] [below of = third,fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$4_S$} & $\dashv$\\
							\circled{$1_A$} & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (fifth) [shape=rectangle] [below of = first]{
						\begin{tabular}{|cc|}
							\hline
							$1_C$ & $b$\\
							\hline
							\hline
							$0_S$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (sixth) [shape=rectangle] [below of = initial]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$2_C$} & $b$\\
							$1_S$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					
					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
					\path[->](second) edge node {b} (third);
					\path[->](third) edge node {c} (fourht);
					\path[->](third) edge [in=-45, out=-135] node [swap] {A} (first);
					\path[->](fourht) [in=-90, out=-135] edge node{C}(second);
					\path[->](fourht) edge node [swap]{d} (fifth);
					\path[->](fifth) edge node [swap]{a} (sixth);
				\end{tikzpicture}
			\end{figure}
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,fill=green] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle,fill=green] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (third) [shape=rectangle,fill=green] [right of = second]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $\dashv$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (fourht) [shape=rectangle] [below of = third,fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$4_S$} & $\dashv$\\
							\circled{$1_A$} & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (fifth) [shape=rectangle] [below of = first,fill=green]{
						\begin{tabular}{|cc|}
							\hline
							$1_C$ & $b$\\
							\hline
							\hline
							$0_S$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (sixth) [shape=rectangle] [below of = initial]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$2_C$} & $b$\\
							$1_S$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (seventh) [shape=rectangle] [below of = fifth]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$2_C$} & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					
					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
					\path[->](second) edge node {b} (third);
					\path[->](third) edge node {c} (fourht);
					\path[->](third) edge [in=-45, out=-135] node [swap] {A} (first);
					\path[->](fourht) [in=-90, out=-135] edge node{C}(second);
					\path[->](fourht) edge node [swap]{d} (fifth);
					\path[->](fifth) edge node [swap]{a} (sixth);
					\path[->](fifth) edge node [swap] {S} (seventh);
				\end{tikzpicture}
			\end{figure}
			Since in $2_C$ there are no other transitions, it is also complete.
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,fill=green] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle,fill=green] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (third) [shape=rectangle,fill=green] [right of = second]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $\dashv$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (fourht) [shape=rectangle] [below of = third,fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$4_S$} & $\dashv$\\
							\circled{$1_A$} & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (fifth) [shape=rectangle] [below of = first,fill=green]{
						\begin{tabular}{|cc|}
							\hline
							$1_C$ & $b$\\
							\hline
							\hline
							$0_S$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (sixth) [shape=rectangle] [below of = initial]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$2_C$} & $b$\\
							$1_S$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (seventh) [shape=rectangle] [below of = fifth, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$2_C$} & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					
					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
					\path[->](second) edge node {b} (third);
					\path[->](third) edge node {c} (fourht);
					\path[->](third) edge [in=-45, out=-135] node [swap] {A} (first);
					\path[->](fourht) [in=-90, out=-135] edge node{C}(second);
					\path[->](fourht) edge node [swap]{d} (fifth);
					\path[->](fifth) edge node [swap]{a} (sixth);
					\path[->](fifth) edge node [swap] {S} (seventh);
				\end{tikzpicture}
			\end{figure}
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,fill=green] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle,fill=green] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (third) [shape=rectangle,fill=green] [right of = second]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $\dashv$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (fourht) [shape=rectangle] [below of = third,fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$4_S$} & $\dashv$\\
							\circled{$1_A$} & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (fifth) [shape=rectangle] [below of = first,fill=green]{
						\begin{tabular}{|cc|}
							\hline
							$1_C$ & $b$\\
							\hline
							\hline
							$0_S$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (sixth) [shape=rectangle] [below of = initial, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$2_C$} & $b$\\
							$1_S$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (seventh) [shape=rectangle] [below of = fifth, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$2_C$} & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (eigth) [shape=rectangle] [below of = sixth]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					
					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
					\path[->](second) edge node {b} (third);
					\path[->](third) edge node {c} (fourht);
					\path[->](third) edge [in=-45, out=-135] node [swap] {A} (first);
					\path[->](fourht) [in=-90, out=-135] edge node{C}(second);
					\path[->](fourht) edge node [swap]{d} (fifth);
					\path[->](fifth) edge node [swap]{a} (sixth);
					\path[->](fifth) edge node [swap] {S} (seventh);
					\path[->](sixth) edge node {a}(eigth);
				\end{tikzpicture}
			\end{figure}
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,fill=green] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle,fill=green] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (third) [shape=rectangle,fill=green] [right of = second]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $\dashv$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (fourht) [shape=rectangle] [below of = third,fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$4_S$} & $\dashv$\\
							\circled{$1_A$} & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (fifth) [shape=rectangle] [below of = first,fill=green]{
						\begin{tabular}{|cc|}
							\hline
							$1_C$ & $b$\\
							\hline
							\hline
							$0_S$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (sixth) [shape=rectangle] [below of = initial, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$2_C$} & $b$\\
							$1_S$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (seventh) [shape=rectangle] [below of = fifth, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$2_C$} & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (eigth) [shape=rectangle] [below of = sixth, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (ninth) [shape=rectangle] [below of = eigth]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $b$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					
					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
					\path[->](second) edge node {b} (third);
					\path[->](third) edge node {c} (fourht);
					\path[->](third) edge [in=-45, out=-135] node [swap] {A} (first);
					\path[->](fourht) [in=-90, out=-135] edge node{C}(second);
					\path[->](fourht) edge node [swap]{d} (fifth);
					\path[->](fifth) edge node [swap]{a} (sixth);
					\path[->](fifth) edge node [swap] {S} (seventh);
					\path[->](sixth) edge node {a}(eigth);
					\path[->](eigth) edge node {b}(ninth);
				\end{tikzpicture}
			\end{figure}
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,fill=green] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle,fill=green] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (third) [shape=rectangle,fill=green] [right of = second]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $\dashv$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (fourht) [shape=rectangle] [below of = third,fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$4_S$} & $\dashv$\\
							\circled{$1_A$} & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (fifth) [shape=rectangle] [below of = first,fill=green]{
						\begin{tabular}{|cc|}
							\hline
							$1_C$ & $b$\\
							\hline
							\hline
							$0_S$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (sixth) [shape=rectangle] [below of = initial, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$2_C$} & $b$\\
							$1_S$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (seventh) [shape=rectangle] [below of = fifth, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$2_C$} & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (eigth) [shape=rectangle] [below of = sixth, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (ninth) [shape=rectangle] [below of = eigth]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $b$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (tenth) [shape=rectangle] [below of = ninth]{
						\begin{tabular}{|cc|}
							\hline
							$1_S$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					
					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
					\path[->](second) edge node {b} (third);
					\path[->](third) edge node {c} (fourht);
					\path[->](third) edge [in=-45, out=-135] node [swap] {A} (first);
					\path[->](fourht) [in=-90, out=-135] edge node{C}(second);
					\path[->](fourht) edge node [swap]{d} (fifth);
					\path[->](fifth) edge node [swap]{a} (sixth);
					\path[->](fifth) edge node [swap] {S} (seventh);
					\path[->](sixth) edge node {a}(eigth);
					\path[->](eigth) edge node {b}(ninth);
					\path[->](ninth) edge node {A}(tenth);
				\end{tikzpicture}
			\end{figure}
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,fill=green] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle,fill=green] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (third) [shape=rectangle,fill=green] [right of = second]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $\dashv$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (fourht) [shape=rectangle] [below of = third,fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$4_S$} & $\dashv$\\
							\circled{$1_A$} & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (fifth) [shape=rectangle] [below of = first,fill=green]{
						\begin{tabular}{|cc|}
							\hline
							$1_C$ & $b$\\
							\hline
							\hline
							$0_S$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (sixth) [shape=rectangle] [below of = initial, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$2_C$} & $b$\\
							$1_S$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (seventh) [shape=rectangle] [below of = fifth, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$2_C$} & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (eigth) [shape=rectangle] [below of = sixth, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (ninth) [shape=rectangle] [below of = eigth, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $b$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (tenth) [shape=rectangle] [below of = ninth]{
						\begin{tabular}{|cc|}
							\hline
							$1_S$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (eleventh) [shape=rectangle] [below of = seventh]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$4_S$} & $b$\\
							\circled{$1_A$} & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};
					
					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
					\path[->](second) edge node {b} (third);
					\path[->](third) edge node {c} (fourht);
					\path[->](third) edge [in=-45, out=-135] node [swap] {A} (first);
					\path[->](fourht) [in=-90, out=-135] edge node{C}(second);
					\path[->](fourht) edge node [swap]{d} (fifth);
					\path[->](fifth) edge node [swap]{a} (sixth);
					\path[->](fifth) edge node [swap] {S} (seventh);
					\path[->](sixth) edge node {a}(eigth);
					\path[->](eigth) edge node {b}(ninth);
					\path[->](ninth) edge node {A}(tenth);
					\path[->](ninth) edge node {c}(eleventh);
				\end{tikzpicture}
			\end{figure}
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,fill=green] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle,fill=green] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (third) [shape=rectangle,fill=green] [right of = second]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $\dashv$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (fourht) [shape=rectangle] [below of = third,fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$4_S$} & $\dashv$\\
							\circled{$1_A$} & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (fifth) [shape=rectangle] [below of = first,fill=green]{
						\begin{tabular}{|cc|}
							\hline
							$1_C$ & $b$\\
							\hline
							\hline
							$0_S$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (sixth) [shape=rectangle] [below of = initial, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$2_C$} & $b$\\
							$1_S$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (seventh) [shape=rectangle] [below of = fifth, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$2_C$} & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (eigth) [shape=rectangle] [below of = sixth, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (ninth) [shape=rectangle] [below of = eigth, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $b$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (tenth) [shape=rectangle] [below of = ninth, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							$1_S$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (eleventh) [shape=rectangle] [below of = seventh]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$4_S$} & $b$\\
							\circled{$1_A$} & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};
					
					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
					\path[->](second) edge node {b} (third);
					\path[->](third) edge node {c} (fourht);
					\path[->](third) edge [in=-45, out=-135] node [swap] {A} (first);
					\path[->](fourht) [in=-90, out=-135] edge node{C}(second);
					\path[->](fourht) edge node [swap]{d} (fifth);
					\path[->](fifth) edge node [swap]{a} (sixth);
					\path[->](fifth) edge node [swap] {S} (seventh);
					\path[->](sixth) edge node {a}(eigth);
					\path[->](eigth) edge node {b}(ninth);
					\path[->](ninth) edge node {A}(tenth);
					\path[->](ninth) edge node {c}(eleventh);
					\path[->](tenth) [in=-135, out=135]edge node {a}(eigth);
				\end{tikzpicture}
			\end{figure}
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle,fill=green] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle,fill=green] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle,fill=green] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (third) [shape=rectangle,fill=green] [right of = second]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $\dashv$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (fourht) [shape=rectangle] [below of = third,fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$4_S$} & $\dashv$\\
							\circled{$1_A$} & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (fifth) [shape=rectangle] [below of = first,fill=green]{
						\begin{tabular}{|cc|}
							\hline
							$1_C$ & $b$\\
							\hline
							\hline
							$0_S$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (sixth) [shape=rectangle] [below of = initial, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$2_C$} & $b$\\
							$1_S$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (seventh) [shape=rectangle] [below of = fifth, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$2_C$} & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (eigth) [shape=rectangle] [below of = sixth, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (ninth) [shape=rectangle] [below of = eigth, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $b$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (tenth) [shape=rectangle] [below of = ninth, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							$1_S$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (eleventh) [shape=rectangle] [below of = seventh, fill=green]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$4_S$} & $b$\\
							\circled{$1_A$} & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};
					
					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
					\path[->](second) edge node {b} (third);
					\path[->](third) edge node {c} (fourht);
					\path[->](third) edge [in=-45, out=-135] node [swap] {A} (first);
					\path[->](fourht) [in=-90, out=-135] edge node{C}(second);
					\path[->](fourht) edge node [swap]{d} (fifth);
					\path[->](fifth) edge node [swap]{a} (sixth);
					\path[->](fifth) edge node [swap] {S} (seventh);
					\path[->](sixth) edge node {a}(eigth);
					\path[->](eigth) edge node {b}(ninth);
					\path[->](ninth) edge node {A}(tenth);
					\path[->](ninth) edge node {c}(eleventh);
					\path[->](tenth) [in=-135, out=135]edge node {a}(eigth);
					\path[->](eleventh) edge node [swap]{C} (eigth);
					\path[->](eleventh) [in=-45, out=45]edge node [swap]{d} (fifth);
				\end{tikzpicture}
			\end{figure}
			N.b.: to check if a state is a duplicate state, is enough to check just the base set, because the closure set is obtained starting from the base set, and 
			for sure will be the same.

			Finally no other transition are left: in the following image there is the clean graph without the green highlights:
			\begin{figure}[H]
				\centering
				\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=2cm]
					\node (initial) [shape=rectangle] {
						\begin{tabular}{|cc|} \hline
							\hline
							$0_S$ & $\dashv$\\
							\hline
						\end{tabular}
					};
					\node (first) [shape=rectangle] [right of = initial] {
						\begin{tabular}{|cc|} \hline
							$1_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (second) [shape=rectangle] [right of = first]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $\dashv$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (third) [shape=rectangle] [right of = second]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $\dashv$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (fourht) [shape=rectangle] [below of = third]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$4_S$} & $\dashv$\\
							\circled{$1_A$} & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (fifth) [shape=rectangle] [below of = first]{
						\begin{tabular}{|cc|}
							\hline
							$1_C$ & $b$\\
							\hline
							\hline
							$0_S$ & $b$\\
							\hline
						\end{tabular}
					};
					\node (sixth) [shape=rectangle] [below of = initial]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$2_C$} & $b$\\
							$1_S$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (seventh) [shape=rectangle] [below of = fifth]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$2_C$} & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (eigth) [shape=rectangle] [below of = sixth]{
						\begin{tabular}{|cc|}
							\hline
							$2_S$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (ninth) [shape=rectangle] [below of = eigth]{
						\begin{tabular}{|cc|}
							\hline
							$3_S$ & $b$\\
							\hline
							\hline
							$0_A$ & $a$\\
							\hline
						\end{tabular}
					};
					\node (tenth) [shape=rectangle] [below of = ninth]{
						\begin{tabular}{|cc|}
							\hline
							$1_S$ & $b$\\
							\hline
							\hline
						\end{tabular}
					};
					\node (eleventh) [shape=rectangle] [below of = seventh]{
						\begin{tabular}{|cc|}
							\hline
							\circled{$4_S$} & $b$\\
							\circled{$1_A$} & $a$\\
							\hline
							\hline
							$0_C$ & $b$\\
							\hline
						\end{tabular}
					};
					
					\path[->](initial) edge node {a} (first);
					\path[->](first) edge node {a} (second);
					\path[->](second) edge node {b} (third);
					\path[->](third) edge node {c} (fourht);
					\path[->](third) edge [in=-45, out=-135] node [swap] {A} (first);
					\path[->](fourht) [in=-90, out=-135] edge node{C}(second);
					\path[->](fourht) edge node [swap]{d} (fifth);
					\path[->](fifth) edge node [swap]{a} (sixth);
					\path[->](fifth) edge node [swap] {S} (seventh);
					\path[->](sixth) edge node {a}(eigth);
					\path[->](eigth) edge node {b}(ninth);
					\path[->](ninth) edge node {A}(tenth);
					\path[->](ninth) edge node {c}(eleventh);
					\path[->](tenth) [in=-135, out=135]edge node {a}(eigth);
					\path[->](eleventh) edge node [swap]{C} (eigth);
					\path[->](eleventh) [in=-45, out=45]edge node [swap]{d} (fifth);
				\end{tikzpicture}
			\end{figure}
			Let's do some final considerations. Notice first that, in this case there it is always one lookahead, but in principle may happen you have more than one lookahead.

			We have seen that a certain point, we started getting repeated: there were clones states with small differences in lookahead (but same stat in the 
			candidate), like $2_S,b$ and $2_S,\dashv$. Somebody told: what if I unify these states with differents lookaheads, what would happen? We would have a slightly less
			powerful recognizer, which is anyway still powerful enough that most of the times we don't see the difference. This is the algorithm that bison uses to 
			build the parser for the laboratory part (LALR algorithm).

			This is not requested in exam.

			In some other exercises we might have \emph{conflicts}. They happen when we build some configurations of states or candidates that makes 
			correct parsing difficult or impossible. For example: two final state in the same macrostate with the same lookahead: if the two lookaheads are the 
			same, we don't know whether to reduce one candidate or the other (this is a \textbf{reduce reduce conflict}, and is one type of conflicts we will see).

			Another conflict is the \textbf{shift reduce}: happens when we have a transition to another state that reads one character, but we have another final state, which is final, which have the same 
			lookahead (a macro state, with a final states with lookahead a terminal, and an outgoing arc from that macro state with the same terminal).

			Another conflict unique to the way in which we build the pilot in this course: it's called \textbf{convergence conflict}: is a bit harder to understand:  happens when 
			multiple transitions in the machine nets, by using the same character, reach the same state with different lookahead.
			The conflict is that by definition, all the candidates in the same macrostate should have a different state. This is important because when we go along and continue building 
			the graph, if we evaluate twice the same state, we get a non deterministic pilot graph. How to solve this? in the new macro state, keep only once the repeated 
			state, and do the merge of the lookahead. To remember that there was a convergence conflict, the arrow incoming which generates the conflict is doubled (from 
			``$\rightarrow$'' to ``$\Rightarrow$'').
			
			The algorithm for pilot graph:

			\begin{itemize}
				\item Create initial state
				\item For each symbol, inside the set of terminal characters and nonterminal character, if we have a transition, then create a new transition and state
				\item Items in the new state are the closure of the initial candidates, but advanced in order to take into account that we made a transition, and we will repeat that until we finish
			\end{itemize}
			Is the ELR1 condition satisfied? If the are no conflicts, then it is ELR1.
			\begin{itemize}
				\item No shift reduce conflicts
				\item No reduce reduce conflicts (no couple of states with the same lookahead in the same macro state)
				\item No convergence conflicts, because we didn't find while building pilot graph
			\end{itemize}
			ELL1? To check it, there are two ways:
			\begin{enumerate}
				\item If we have already build the pilot graph for the ELR condition, just need to check the following three conditions must holds:
				\begin{enumerate}
					\item No left most recursion (we have no machines in the machine net (the one given by exercise, not the built pilot) where after the initial state we immediately recognize a nonterminal)
					\item The pilot graph has the single transition property (STP: we do not have any of the macro states with a base set of multiple items)
					\item The language is ELR1 (we can build ELR without conflicts).
				\end{enumerate}
				\item If we do not have the pilot graph, we do not need to build it. We need to build ELL parser control flow graph. ELL differs from ELR because it is sorta of greedy.
				If it finds a situation where he could recognize some nonterminal he does not consider the fact that there might be others nonterminals that could not be recognized simultaneously 
				because the grammar overlaps slightly, it just looks at the first character that starts at the beginning of each production. In the case of before: when we have $A$, if then we read a character $c$,
				Then it is ofcourse our production of $A$. Of course this has problems: not all context free languages can be recognized by ELL parser. However, the logic of a ELL parser, and in general of 
				LL and topdown parser is so simple, is so easy to write a program that implements the parser manually. How to build the parser control flow graph? for example, $4_S$: if the next 
				character is $d$, then of course is $C$. To represent this logic in the machine net, we add the so called \index{Guide Sets}\textbf{Guide Sets}. Guide sets tell us which is the set of characters 
				we need to find after the last character we have read at each state in order to be able to transfer control to decide for example: ok is not production $S$, is $C$. Example: $3_S$ can read $A$.
				At the beginning of $A$, we have $c$: dashed arc $3_S$ to $0_A$, and the guide set is $c$. $4_S$ to $0_C$, guide $d$. $1_C$, $0_S$, with guide $a$: set of characters will appear at 
				beginning of machine. If we have multiple transition from the same state, look at all the characters we have. If we have a nonterminal, go inside recoursively the starting character.
				Once we have build the guide sets, to tell if it is ELL1, we need to check if there is no left most recursion, and if adding guide sets and real arcs would build an ambiguous or nondeterministic 
				graph. In the example, everything will be ambiguous $3_S$, we can read $c$ staying in $S$, and a guide set with $c$ that brings to $A$. Being the two sets of characters are equal, once we reach $3_S$, 
				we don't know which path to take. Need to check if there it is an ambiguity after having inserted the guide set.
			\end{enumerate}
			The exams asks to do explicitly with one method or with the other. If the choose is left up to you, look at what you already have % exercise session 20221110 Prof Cattaneo complete
		\subsection{ELL parsers}
			ELL = Extended Left to right Leftmost

			ELL parsers are among the most basic top down parsers; the idea is to mimic the traversing of the machines network. The string is 
			\emph{progressively generated} using the grammar rules character by character until $\dashv$ is reached. ELL parsers relies on a stronger assumption 
			than ELRs: so that the input string can identify the rule that produces it \emph{starting from the first character}.

			The most used technique is to enrich the arcs of the pilot automaton with "guide sets" that communicate the next characters that can be encountered. 
			Relying on a stronger hypothesis means being effective in fewer cases: ELL parsers can't be built if
			\begin{itemize}
				\item Multiple transitions between states are defined. This simply means that ELL parsing isn't applicable to \emph{all} the pilot automata where 
				two or more states in the same m-state originate an arc with the same label;
				\item There are left-recursive derivation;
				\item The pilot automaton does not meet ELR condition (ELL represents a smaller set of languages). 
			\end{itemize}
			These three conditon form the \textbf{ELL condition} for automata.
			
			\subsubsection{Parser Control Flow Graph}
				A PCFG is a representation of the automata that compose the machine network that \emph{links} them all together, highlighting subsequent calls 
				and recursive dependencies. From the PCFG it's easy to derive directly the parser code.

				Starting from the machine net graph, building a PCFG means:
				\begin{enumerate}
					\item adding call arcs: these arcs connect the states that have an outgoing arc labeled as nonterminal with the first state of the machine that 
					recognizes that nonterminal;
					\item labeling call arcs: every call arc is enriched with a set of nonterminals that are the "guide set" for that call. This set of nonterminals 
					is composed of all the followers of that call:
						\begin{itemize}
							\item token that are the initials of the language generated by the submachine
							\item the empty string if the language of the subm is nullable
							\item the nonterminals that labels the subsubcalls to other submachines
						\end{itemize}
					\item enriching final states with so-called "prospect sets": prospect sets are the union of \emph{all} lookahead sets of \emph{all} the 
					occurrence of that state in the pilt automaton. This union of sets must be found watching the pilot automaton. 
				\end{enumerate}
				
				\paragraph{Example}
					We build the PCFG for the grammar in (5), so to have a continuity.
					\begin{figure}[H]
						\centering
						\includegraphics[width = \textwidth]{./images/PCFG.png}
					\end{figure}
			 
			\subsubsection{ELL test}
				Given the PCFG, we can easily check if an automata is ELL by exploiting a corollary of the ELL condition itself, which states that a machine network 
				satisfies ELL iff for each state, all the outgoing arcs' guide sets are disjoint. The double implication means that building the PCFG and checking 
				the disjointness of the guide sets proves if a machine network satisfies ELL or not.

				\emph{\textbf{This means we can avoid building the pilot automaton to check for ELL property}}
				
			\subsubsection{Possible implementation techniques}
				This short paragraph explains how to implement a predictive parser (but not why, tho) by means of two of the most common techniques.
				\begin{itemize}
					\item Recursive procedures: every submachine is encoded as a single procedure that scans the input tape char by char and that analyzes the input 
					token as the automaton would: guide sets and arc labels are used to build the patterns to match the current character against. Termination of a 
					subprocedure: acceptance; else an error is thrown. To recognize a nonterminal the associated procedure is called. (A lot of talking for an 
					implementation technique that's really simple in practice: just modularize the code according to the machines in the network).
					\item Explicit stack: this method does not take advantage of the recursiveness to memorize the state of the application, instead it saves it on 
					the stack directly. The parser can perform 4 different moves (here with "replace q with r" is intended pop q push r):
						\begin{enumerate}
							\item scan: if the shift arc q $\rightarrow$ r exist, then q is replaced with r.
							\item call: move performed when a submachine is invoked. Pop of the current state, push of the first state after call (so if 
							$q \xrightarrow{B} r$ replace q with r and push $0_B$), push of the first state of the called machine.
							\item return: the next character is in the prospect set of the current state, which is final: pop.
							\item recognition: if we are in the final state of the axiom machine and the current character is $\dashv$, recgnize and halt. Otherwise, 
							error and halt.
						\end{enumerate}
				\end{itemize}
				
			\subsubsection{Lookahead lenghtening}
				Often it's sufficient to increase the lenght of the lookahed (to more than one token) to render a top down parser deterministic fom a non-ELL grammar. 
				In this course, the only method is a "eagle eye" one where you spot the perfect lenght just looking at the PCFG and choosing which minimum lookahed 
				set grants determinism, basing yourself on pure parser instinct.
				
		\subsection{Earley algorithm}
			The Earley algorithm is a method to recognize strings from a grammar even if this is ambiguous. The pseudocode approach both the book and the slides take 
			is very counterintuitive, in my opinion. So, I will try just to explain \emph{how practically} a Earley recognizers is built and used. Keep in mind that 
			this procedure should build \emph{a software}.

			First, initialize the vector of candidates to E = \{ $\langle 0_s, 0 \rangle$ \} that represent the initial state and the first value

			Then, with $n$ taken as the lenght of the string to recognize, we initialize all the elements of E[1..n] to the empty set.

			We complete the first element E[0]. Completing an element (applying the \emph{completion} operation to it) means computing the closure of the state (and 
			adding to the E[i] set of candidates the closure's states) and calculating also all the states that are reachable through a nonterminal shift (watch out: 
			with nonterminal shift we are referring to the operation of "arriving on E[i] with a nonterminal shift", not leaving this state), adding them also to the 
			state.

			We then compute, for every token in the string, the \emph{terminalshift} for every element in the vector (terminalshift means nonterminalshift with 
			terminal symbols. For every candidate in previous state that can terminalshift to a candidate in the current state add that transiction [represented as 
			the candidate $state, index - 1$] to this vector element) to build the shifting operation, then we complete it.

			This algorithm is similar to the method to build a pilot automaton, but instead of lookahed sets just the position in the vector of the caller state is 
			memorized. The string is accepted if the last element of the vector is of type $\langle finalstate, 0 \rangle$: this means that the condition is 
			accepting (finalstate) and the whole string is accepted (0).
			
			These example and notation should clear all remaining doubts:
			\begin{figure}[H]
				\centering
				\includegraphics[width = \textwidth]{./images/exEarley.png}
			\end{figure}