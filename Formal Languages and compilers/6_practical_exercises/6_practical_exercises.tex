\chapter{Practical exercises}
    \section{Exercise 1}
        \subsection{Indistinguishable states}
            While speaking of clean automaton \ref{sect:cleanautom}, a \emph{practical} translation of the definition \ref{def:undiststates}, chapter is: two states are 
            undistinguishable if the outgoing arcs with the same label brings to the same state (and their outgoing arcs have the same lable), or, in other words, 
            equal lable $\Rightarrow$ same state.
        \subsection{Linear Language Equations}\label{ese:linlangeq}
            Referring to section \ref{sect:linlangeq}
            In order to pass from grammar rules to linear language equations, substitute the $\vert$ symbol with $\bigcup$, and each nonterminal with a sublanguage.
        \subsection{Local automaton / language}\label{sect:practlocautom}
            Referring to definition \ref{def:loclang}, when we are asked to define whether a language is local and we have the minimal automaton available, we can check 
            whether the automaton is local. In order to do so, we can say that the automaton is local when does not exist two arcs with different labels going into 
            different states (needs to be minimal otherwise the arcs could end up in two different states, which are the same in reality).

            In case the automaton is not available, we have to find $Dig$, $Fin$, $Ini$ and check whether all their components can be recognized.
        \subsection{Finding class of grammars}
            Refferring to table \ref{tab:typelang}, we can distinguish Context Free Grammars and Regular by watching non terminals in grammar rules.

            For Regular:
            \begin{itemize}
                \item On the left of the rule, we have only one nonterminal;
                \item On the right part fo the rule, we must have one nonterminal;
                \item Inside the right part of the rule, the nonterminals must be all on the left or the right.\footnote{N.B.: every rule of the grammar must have 
                the nonterminal on the left or on the right part of the right part of the rule. Or \textbf{every} rule have it on the right, or on the left.}
            \end{itemize}
            For context free grammars, we remove the last two points.
        \subsection{Ambiguity of automaton}
            For definition of \index{Ambiguity}ambiguity refer to the section \ref{sec:ambig}.
            An automaton is ambiguous if enables two or more accepting paths for the same string. Note that also epsilon path: in fact, if you find an epsilon loop
            it is ofr sure ambiguous.
        \subsection{Argue that is ambiguous}
            Sometimes it is asked to argue whether a grammar is \index{Ambiguity}ambiguous or not. It could be enough to argue that an order in nonterminals is 
            imposed by the grammars, and we don't spawn two equal nullable nonterminals.%//TODO: check this thing. ref: pag 28 2.1 divided exercises
        \subsection{Remove Ambiguity}
            To remove \index{Ambiguity}ambiguity, we have different ways: for example, try introducing others nonterminals, or try to see if the ambiguity 
            comes from a repeated adjacent nullable nonterminals. For example may be useful from a nonterminal, generating an even number of letters and ending 
            in the end with a single terminal in order to be able also to generate an odd number:
            $$
                G:\quad\begin{cases}
                    \ldots
                    X\rightarrow aaX\vert a
                    \ldots
                \end{cases}
            $$
            Split instead in this way: generate for example couples of $a$, which will generate an \emph{even} number of $a$, and terminate going with a single $a$
            (in this way, you can generate also odd numbers of $a$).

            If you want to remove \index{Ambiguity}ambiguity coming from the union of languages (they may have strings in common, and adding an axiom of the 
            type $S\rightarrow S_1\vert S_2$ could introduce ambiguity), we could first generate the grammar from the second language, then slightly modify it in 
            order to avoid the generation of the strings in common (before modifying could be helpful writing the slightly modified language).
        \subsection{Formal proof of non ambiguity}
            Refer to section \ref{sect:formalproofambiguity}.
    \section{Exercise 2.1}
        \subsection{Regular languages and context free}
            Remember: a context free language example can be $a^nb^n$. A regular language is context free, but a context free language is not always regular: for example
            $a^nb^n$ is context free but not regular. Remember that context free is \textbf{not} closed with respect to $\cap$. An intersection of two context free 
            languages \textbf{may} still \textbf{be} context free, but it is not guaranteed.
            %//TODO: aggiungere teoria di questa parte
        \subsection{Deterministic vs. non deterministic automaton from grammar}
            Given a grammar, how to check whether the corresponding automaton is deterministic or not? In a deterministic automaton, given an input I need to know for 
            sure in which state I will end. Epsilon moves makes the automaton nondeterministic, and a copy rule corresponds exactly to an epsilon move (spontaneous move):
            So, if you have an alternative such as:
            $$X\rightarrow aT \vert \varepsilon$$
            $$T\rightarrow aT\vert V$$
            $$V\rightarrow bV\vert cV\vert\varepsilon$$
            The automaton is nondeterministic: in $T$ is like if you don't know whether to spontaneously go in $V$ or stay in $T$ to wait for an $a$.
        \subsection{Is a language regular?}
            If it is writable through a regex, it is. If it is the intersection of two regular languages, it is ($REG$ is closed with respect to the intersection).
        \subsection{Automata, languages and grammars}
            \begin{table}[H]
                \label{tab:typelang}
                \centering
                \begin{tabular}{cccc}
                    \toprule
                    \textbf{\tableline{Chomsky\\hierarchy}} & \textbf{Grammars} & \textbf{Languages} & \textbf{\tableline{Minimal\\Automaton}}\\
                    \midrule
                    Type $0$ & Generals & \tableline{Recursively\\numerable} & Turing Machine\\
                    Type $1$ & Context dependent & Context dependent & \tableline{Linear Bounded\\Automaton\\(LBA)}\\
                    Type $2$ & Context Free & Context Free & NPDA\\
                    Type $3$ & Regular & Regular & FSA\\
                    \bottomrule
                \end{tabular}
            \end{table}
        \subsection{Closure Properties of Languages}
            Please refer to table \ref{tab:closprop}.
